### No.1
プリエンプションは実行状態から実行可能状態にシフトさせる

### No.2
スラッシング -> ページ置き換えの発生頻度が高くなり，システムの処理能力が急激に低下すること

### No.3
ラウンドロビン -> タイムシェアリングシステムに適している（総当たり）

### No.4
CPUが3秒終わって，Aはディスクの処理に移る．
その時BはCPUを触ることができるので処理を開始できる

### No.5
LRU -> 最後に参照された時刻が最も更かしであるものを置き換え対象とする

### No.7
I/Oが競合する回数を求める
ぶつかったら優先度高いやつにタスクをぶん取られるのでそこでおしまい

### No.8
左から順に入れていき，右に挿入できなくなったらまた左に戻る
数値の落ちた回数を数える

### No.9
タイムシェアリングシステムだと1,2,3と生成順に割り込んでいき，3が終了したあとまた1を終わらせに行く

### No.10
ページインの割合をPとし，ページアウトする割合を(1-P)とすると
20 * P + 60 * (1-P) = 30 後は計算

感覚として0.75

### No.11
LRUはここ最近で最も長い時間使用されていないページを置き換える

### No.12
ノンプリエンプティブ -> 到着順，並列
プリエンプティブ -> CPU割当を管理して順次実行

### No.13
優先度が高いやつが実行可能状態になったら，優先度が低いやつがプリエンプションして実行可能状態にさせられる

### No.14
デマンドページングは要求して，ロードする

### No.15
ラウンドロビン方式 -> 各プロセスを待ち行列の順にタイムクウォンタムずつ処理し，終了しないときは待ち行列の最後につなぐ

### No.17
容量は二つあるので，AとBを別個に考えていけばよい

### No.18
右手フォーク問題的に考えて，どっか一つでもデッドロックになったらおしまい

### No.19
使用できない領域とは，ベストフィット手法で入れて余ったスペースのことである

### No.20
プリエンプティブ -> 強制的にプロセスを切り替える機構が必要

### No.22
論理アドレスから物理アドレスに変換するときは，主記憶に存在するページをアクセスする時

### No.25
処理時間方式は，処理時間が短いやつからやっていく

### No.30
ページング方式の仮想記憶 -> データを不連続な主記憶に割り付けられる

### No.31
LRU方式 -> 最も古くに参照されたやつから消えていく

### No.32
優先度高いやつがやったあと，そこの間に優先度低いやつを入れていく感じ

### No.33
実行完了状態 -> 待ち状態 -> 実行状態という流れ

### No.37
デマンドページング方式 -> ページフォールトが発生した時，当該ページを書き込む

### No.38
スケージューリング方式 -> 優先度順方式（そりゃ優先度だわ）

### No.40
FIFOはキュー

### No.41
優先度低いけど，実行権限はあるらしくI/O競合するらしい

### No.42
ページサイズを半分にすると，ページ内の無駄な空き領域が減少するので，主記憶不足が緩和される

### No.44
ループのような近いところを参照する処理は，局所参照性が高くなる

### No.45
リアルタイムOS -> タスクの生成は主に静的に行う(やること先に決めるらしい)

### No.48
一回のアクセス時間 * アクセス回数で総合アクセス時間を出す．
その後総合アクセス時間 + オーバーヘッド時間で一回試行にかかる時間が求まる

あとは1秒で何回いけるか

### No.51
デッドロック -> 資源獲得の順序を両方のタスクで同じにする

### No.54
マイクロカーネル -> OSの中で中核をなす機能を担う部分のことでスーパバイザプログラム
OSが，最小限の機能をもつ中核部分と，それ以外のサブシステムからなる。

### No.56
2^L／2^N＝2^L-N

L－N＋E
暗記


### No.59
実行状態 -> 実行可能状態 -> 実行状態

### No.60
ファイル領域割当て方式 -> ファイルの作成と削除を繰り返しても，ファイルに割り当てられない無駄な領域が発生しない

### No.63
ページフォールトならばページイン処理をおこない，ページ内変位を加えて求める主記憶アドレスを得る

### No.64
ページフォールト * n <= 目標時間

### No.68
FIFOにはある種のページアクセス順序に対して主記憶のページ枠を増やすとかえってページフォールトの回数が増えてしまう

### No.69
スラッシング -> 仮想記憶システムにおいて主記憶の容量が十分でない場合，プログラムの多重度を増加させるとシステムのオーバヘッドが増加し，アプリケーションのプロセッサ使用率が減少する状態

### No.71
ジョブはコンピュータで実行されるひとまとまりの処理であり，一つ以上のジョブステップから構成される

### No.73
タイムクォンタムを短くすると，OSが切り替えるので，OSの処理が多くなる．
またアプリケーションの効率もアガる

### No.82
多重プログラミングでスループットが低下 -> 演算処理が中心となるプログラム同士

### No.83
SPTは短い順に実行するので，対話型処理の平均応答時間を最小にできる

### No.85
デッドロックは，同じ順序で取り合う場合は起きない

### No.88
FIFOは割当領域増やすときつい

### No.89
セマフォ ->
P操作，待ち行列の先頭のタスクをクリティカルセクションに入れる
V操作，待ち行列にタスクが存在すれば，先頭のタスクをクリティカルセクションに入れる

### No.90
プリエンプティブ方式は，前もって優先度を決めるので，そんなに独占はされない

### No.91
仮想アドレス，物理アドレスと対応付けるアドレス変換機能 -> 記憶保護

### No.92
時間監視処理 -> 資源の解放待ち
デッドロックが起きるかどうかを確認する

### No.93
### No.94
### No.95
### No.96
### No.97
### No.98
### No.99
### No.100
### No.101
### No.102
