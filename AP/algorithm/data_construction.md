### No.1
横からどばーっとやっていっている

### No.2
親があって子が二つあったら，木
ループを作ってはダメらしい

### No.3
五本伸びていると考えたらできる

### No.4
ABCとか出てくる通りを列挙して可能な個数を出す

### No.5
スタックはLIFO(Last in First out)
後から入ってきたものが先に出ていく表現
キューはFIFO

### No.7
葉の個数がn個だったら，葉以外での節点はn-1個

### No.8
配列だと最後に入れたところのindexがあればスタックは実現できる

### No.11
現在の状態から逆順でやっていく
ポイントはPUSHで取り除いて，POPで入れるみたいに逆の処理をやればいい

### No.12
末尾のアドレスしか持っていないので，末尾の一つ前のアドレスを取得する場合は先頭から見ていく必要がある．

### No.13
rearが無いと末尾のアドレスを持っていないので，nの数かかる

### No.14
キューは途中の挿入や削除を行えるらしい

### No.15
B木はバランスを取る
B木はバケットが溢れたら，木を伸ばしてそいつに値を分け与える感じ

### No.16
親の番号を入れる的な感じ


### No.19
二分木の探索はlog2n
半分ずつ対象が減っていくとlog2n

### No.20
ヒープは親が大きかったらいい感じ

### No.23
全然分からん

### No.24
二分木は連結リストより効率がよい

### No.25
根を削除すると一番下の葉が上に上がってくる．
その後追加する場合は適切な場所に置く


### No.27
追加と取り出しだけ見たら，先頭と後ろのアドレス知っているだけで最高

### No.28


### No.29
### No.30
### No.31
### No.32
### No.33
### No.34
### No.35
### No.36
### No.37
### No.38
### No.39
### No.40
### No.41
### No.42
