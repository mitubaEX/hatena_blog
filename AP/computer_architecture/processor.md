### No.1
パイプライン実行は一つづつずらして並べていく感じ

### No.2
レジスタは次の命令のアドレスを保持している

### No.4
アドレスのアドレス

### No.5
VLIWはまとめて実行おじさん

### No.6
スタックは戻り先アドレス及びレジスタの内容を格納するメモリのアドレス

### No.7
SISD -> 一つのストリームで一つのデータ
SIMD -> 一つのストリームで複数のデータ
MISD -> 複数のストリームで一つのデータ
MIMD -> 複数のストリームで複数のデータ

### No.8
パイプライン制御は分岐を少なくしろ
順次実行していくノリ

### No.9
スーパースカラはパイプラインを複数用意して，高速化を目指す

### No.10
登記実行は，分岐先を予測して先攻実行していく
予め予測した分岐先の命令の実行を開始する

### No.11
パイプラインが分岐先の命令を取得する方法は，制御ハザード
構造ハザードはメモリアクセスの競合が発生した時
データハザードは，処理するデータの依存関係が原因

### No.14
MIPSは，1秒間の命令実行回数を百万単位で表すCPU性能
100MIPSは一秒間に100百万回実行可能
この問題だと1ミリ秒で1万命令， 1万*1000で秒間の命令数である

これは10百万なので，100 - 10 = 90で答えは90

### No.15
優先度低いやつは高いやつの処理を一旦行った後に戻ってくる感じ

### No.16
絶対アドレス部は，命令のアドレス部をそのまま実行アドレスにする

### No.17
実行速度*出現頻度してナノ秒求めて，それを1秒で割る

### No.20
スーパースカラ -> ハードウェアが動的に割り当てる

### No.21
CPUクロック周期 * CPIで処理時間が求まる

### No.25
(I + D - 1) * P
I: 実行する命令数
D: パイプラインの深さ
P: パイプラインのピッチ

### No.26
ビッグエンディアン -> データの上位バイトから下位バイトへ向かって，メモリの下位アドレスから順に配置していく方式．
つまり昇順

リトルエンディアン -> つまり降順

今回だと 00 01 02 03というデータがある．
これをリトルエンディアンで表記すると，03020100
これをビッグエンディアンで表記すると，00010203

### No.27
MIPS = Hz(クロック周波数) / clock数

### No.30
クロック周期 * CPI

### No.35
MIPS = クロック周波数 / CPI

MIPSが一番高いやつが勝つ

### No.37
式変形して P = 10n / (9 + n)までもっていく
nが無限大に行くと考えた時，9という数字を無視できる．
そして無視すると10n / nとなり P = 10
答え10

### No.39
命令フェッチ -> 命令の解読 -> オペランド読み出し -> 命令の実行

とりま命令を読んでから，オペランドの値を参照して実行する

### No.46
FLOPSは，演算性能指標
MIPSは，1秒間に何回実行できるかの指標

### No.48
機器を6倍いいのに変えたよという話
1/6して以前の性能をだし，それと今を1とした時の差分を求める


### No.50
RISCはハードウェア回路とパイプラインの技術を使い，1命令当たりおおよそ1クロックで実行できる．

### No.51
とりあえず降順らしい

