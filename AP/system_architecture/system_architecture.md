### No.1
ハイパバイザ -> 1台のコンピュータで複数の仮想マシン環境を実現

### No.2
ストアドプロシージャ -> アプリケーションプログラムからネットワークを介してDBMSにアクセスする場合，両者間の通信料を削減できる.

### No.3
CDN -> 動画や音声などの大容量のデータを利用する際に，インターネット回線の負荷を軽くするためにサーバを分散配置する

### No.4
DBへのアクセスは，接続 -> SQL -> アクセス -> HTML -> ブラウザへ送信 -> DBの切断

### No.5
クラスタリング -> 障害が起こった時，切り替え時間が短く，安定して運用できる．

### No.6
3層クライントサーバーシステム -> ユーザの入力を受け取るプレゼンテーション層，業務処理に仕損するデータ加工を行うファンクション層，データベース処理を行うデータ層，
別のOSでもOK

### No.7
今回だと総コア数が4倍なので，まず前の総コア数を求めて4倍する -> 1000 * 8 * 4 = 32000
コア数/1ノードも2倍されているので，前のコア数/1ノードを2倍する -> 8 * 2 = 16
総コア数 / (コア数/1ノード)でノード数を求める -> 32000 / 16 = 2000

総理論ピーク演算性能は，理論ピーク演算性能/1コア * コア数で求める

### No.9
アクセス透過性 -> 遠隔地にある資源にアクセスする際に，同一の方法でアクセスできる

### No.10
フェールセーフ -> システムに障害が発生しても，常に安全側にシステムを制御する

### No.11
クラスタリングシステムのノード障害が発生した時，障害ノードを排除し代替ノードでアプリケーションを実行させるフェールオーバ機能が働く

### No.12
フォールトアボイダンス -> システム構成要素の個々の品質を高めて故障が発生しないようにする

フェールセーフ -> 故障が生じたら，予め定められた安全状態にシステムを固定し，全体として安全が維持されるような設計

フォールトトレランス -> 故障がハッセした場合でも機能を縮退させること無く稼動を継続する

フールプルーフ -> ユーザの誤操作によってシステムがダウンしてしまうことのないように，単純なミスを発生させないようにする設計方法である。

### No.13
ストアドプロシージャ -> なるべく大きな単位で転送することにより，スループットを向上させる

### No.14
グリッドコンピューティング -> PCから大型コンピュータまで，ネットワーク上にある複数のプロセッサに処理を分指して，大規模な処理を行う．
グリッド -> 巨大って感じ

### No.15
RAID0 -> 複数のディスクにデータを分散して書き込むストライピング
RAID1 -> 2台の磁気ディスクに同じ内容を書き込むミラーリング
RAID2 -> ストライピング＋エラー訂正用のハミング符号をディスクに書き込む。最少でも5台構成となる。
RAID3 -> ストライピング＋エラー修正用にパリティビットを1台のディスクに書き込む
RAID4 -> RAID3のパリティビットの書き込みをブロック単位で行う。
RAID5 -> パリティビットもデータと同様に分散して書き込む。

データ及び冗長ビットの記録方法と記録位置との組み合わせ

### No.16
スケールアウト -> 台数増やそう


### No.18
シンプロビジョニング -> 外部記憶装置群を仮想化して物理的な記憶容量より多くの容量を利用者に割り当てることを可能にする
実際の使用量に応じて，容量を割り当てる

### No.21

RAID5 -> 分散
RAID4 -> 1ブロックごとにストライピング

### No.22
ファンクション層 -> データ処理条件の組み立て，データの加工

### No.23
RAID1によって，レプリケーション的なことして，容量の半分を同じデータが食う
今回だと 80 * 8 / 2 = 320Gバイトしかデータがはいらない


### No.28
マルチプロセッサがちょい遅いのは，主記憶への競合が発生するからである．

### No.30
ストアドプロシージャ -> クライアント・サーバ間の通信料を削減する

### No.31
NASは各種OSから触れる

### No.34
クライアントサーバのストアドプロシージャを活かした構成は，クライアントにプレゼンテーション，ファンクション，サーバにファンクション，データベース

### No.35
フェールバック -> 障害が起きた時にノードが他のノードに交代して，再起動を行い起動したらまた交代する

フェールオーバは，交代してその後そいつは起動しない

### No.36
RPC -> 他のコンピュータの手続きを呼び出せる

### No.37
ホットスタンバイ -> 現行系と同じことをやらせておき，現行系が死んだら切り替える


### No.39
疎結合マルチプロセッサ -> OSメモリCPUが二つあって，CPU同士でつながっている
蜜結合マルチプロセッサは，OS一つにCPUがたくさんついている


### No.42
今回だと1時間のトランザクション数が最大72000なので，これを秒に直す -> 72000 / 36000 = 20
一秒に20トランザクションなので，今回は2個のCPUでおっけい

### No.45
疎結合マルチプロセッサ -> CPUが通信するんではなく，普通に通信ポートで通信する

### No.49
仮想化は，オーバーヘッドによる負荷が大きくなる
そりゃ仮想化してるし

### No.51
2層のアーキテクチャだとクライアントが直接DB触る

### No.57
グリッドコンピューティングは，中央のサーバが処理を並列可能な単位に分割してそれを複数にPCに流す

### No.58
フェールソフトは，性能が落ちても処理を続行する

### No.59
ストアドプロシージャ -> 利用頻度の高い命令群を予めサーバに持っておく
ネットワーク負荷を軽減できる
クライアントは手続きを発行して，その手続の中の複数のクエリをサーバは実行する

### No.60
RAID5はパリティの保存に1台使う
今回だと 5台あるけど4台分の容量になる

### No.64
ストライピング -> 複数のディスクに分指してデータを書き込むことで，アクセス性能を向上

### No.65
スーパーコンピュータ -> ベクトル命令を備えたプロセッサを数個ー数十個，またはマイクロプロセッサを数百個結合することに寄って性能向上を測っている
つまりプロセッサをぶち込みまくっている
ベクトル命令を備えたプロセッサ -> アレイプロセッサ

### No.67
垂直機能分散システム -> サーバを幾つかの階層に分け，従属関係を用いる
水平分散 -> 同等の関係にあるコンピュータ同士が分担する

機能分散 -> 階層分担
水平分散 -> 平等分担
負荷分散 -> 同じヤツたくさん立てる

### No.68
SAN -> ストレージをファイバチャネルというプロトコルでつなぐ
Storage area network
別の帯域で動く凄いやつ

### No.69
ピアツーピア，フラッディング -> 隣接ノードに対してデータ検索クエリを投げて，求めるデータを探しに行く

### No.70
フォールトトレランス -> 各機器を二重構成にして，故障に耐える

### No.84
RAID0は性能向上だけ目指した

### No.85
### No.86
### No.87
### No.88
### No.89
### No.90
### No.91
### No.92
### No.93
### No.94
### No.95
### No.96
### No.97
### No.98
### No.99
### No.100
### No.101
### No.102
